2. Write a short paragraph explaining why your program is immune to deadlock?

- By definition, taken from the notes, Deadlock is “a situation in which threads can wind up permanently waiting.” In this specific case, the philosophers would be permanently waiting for one of their chopsticks while holding a chopstick that is required by another philosopher beside them to dine. The program is immune to deadlock by using a global semaphore and a semaphore for each philosopher. The semaphores serve as mutexes to synchronize philosopher activity. First, the program initialized the universal semaphore, and the individual semaphores, to handle synchronization before the threads are forked. After forking each thread, a philosopher (thread) can not attempt to pick up (acquire) a chopstick (mutex) until the universal mutex shared among all philosophers (threads) is released. Once released, a philosopher is opened to acquiring (locking) the universal mutex in order to scan the current state of their neighbors to see if they can pick up both chopsticks without the worry of their neighbors trying to attempt the same thing. With this implementation, each philosopher will be able to dine and will not block one of their neighbors which could spark a chain event blocking each philosopher ultimately leading to deadlock.
